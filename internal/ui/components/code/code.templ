package code

import (
	"bytes"
	"strings"
	"github.com/alecthomas/chroma/v2"
	"github.com/alecthomas/chroma/v2/formatters/html"
	"github.com/alecthomas/chroma/v2/lexers"
	"github.com/alecthomas/chroma/v2/styles"
)

// Props contains configuration for the code viewer
type Props struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Language   string
	Code       string
	ShowLines  bool
	MaxHeight  string
	Padded     bool
	NoBorder   bool
	Wrap       bool
}

css codeContainer() {
	border: 1px solid var(--color-border);
	border-radius: 6px;
	overflow: hidden;
	font-family: var(--font-mono);
	font-size: var(--text-xs);
	background-color: var(--color-background);
}

css codeHeader() {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0.5rem 0.75rem;
	border-bottom: 1px solid var(--color-border);
	background-color: var(--color-surface);
}

css codeLanguage() {
	font-size: var(--text-xs);
	color: var(--color-text-muted);
	text-transform: uppercase;
}

css codeContent() {
	overflow: auto;
	margin: 0;
}

css codeNoBorder() {
	border: none;
	border-radius: 0;
}

// Viewer renders code with syntax highlighting
templ Viewer(props Props) {
	<div
		if props.ID != "" {
			id={ props.ID }
		}
		class={ codeContainer(), templ.KV(codeNoBorder(), props.NoBorder), templ.KV(props.Class, props.Class != "") }
		role="region"
		aria-label="Code viewer"
		{ props.Attributes... }
	>
		if props.Language != "" {
			<div class={ codeHeader() }>
				<span class={ codeLanguage() }>{ props.Language }</span>
			</div>
		}
		<div
			class={ codeContent() }
			if props.MaxHeight != "" {
				style={ "max-height: " + props.MaxHeight }
			}
			tabindex="0"
		>
			@templ.Raw(highlightCode(props.Code, props.Language, props.ShowLines, props.Padded, props.Wrap))
		</div>
	</div>
}

// Simple renders code without the header
templ Simple(props Props) {
	<div
		if props.ID != "" {
			id={ props.ID }
		}
		class={ codeContainer(), templ.KV(codeNoBorder(), props.NoBorder), templ.KV(props.Class, props.Class != "") }
		role="region"
		aria-label="Code"
		{ props.Attributes... }
	>
		<div
			class={ codeContent() }
			if props.MaxHeight != "" {
				style={ "max-height: " + props.MaxHeight }
			}
			tabindex="0"
		>
			@templ.Raw(highlightCode(props.Code, props.Language, props.ShowLines, props.Padded, props.Wrap))
		</div>
	</div>
}

func highlightCode(code, language string, showLines, padded, wrap bool) string {
	// Get lexer for language
	lexer := lexers.Get(language)
	if lexer == nil {
		lexer = lexers.Fallback
	}
	lexer = chroma.Coalesce(lexer)

	// Use GitHub dark theme
	style := styles.Get("github-dark")
	if style == nil {
		style = styles.Fallback
	}

	// Create formatter with options
	options := []html.Option{
		html.WithClasses(false),
		html.PreventSurroundingPre(false),
	}
	if showLines {
		options = append(options, html.WithLineNumbers(true))
	}
	formatter := html.New(options...)

	// Tokenize and format
	iterator, err := lexer.Tokenise(nil, code)
	if err != nil {
		return escapeHTML(code, padded)
	}

	var buf bytes.Buffer
	err = formatter.Format(&buf, style, iterator)
	if err != nil {
		return escapeHTML(code, padded)
	}

	result := buf.String()
	if padded || wrap {
		var styles string
		if padded {
			styles += "padding: 1rem; "
		}
		if wrap {
			styles += "white-space: pre-wrap; word-wrap: break-word; "
		}
		result = strings.Replace(result, `<pre style="`, `<pre style="`+styles, 1)
	}
	return result
}

func escapeHTML(s string, padded bool) string {
	var buf bytes.Buffer
	for _, r := range s {
		switch r {
		case '<':
			buf.WriteString("&lt;")
		case '>':
			buf.WriteString("&gt;")
		case '&':
			buf.WriteString("&amp;")
		case '"':
			buf.WriteString("&quot;")
		default:
			buf.WriteRune(r)
		}
	}
	padding := "0"
	if padded {
		padding = "1rem"
	}
	return "<pre style=\"margin: 0; padding: " + padding + ";\">" + buf.String() + "</pre>"
}
